"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFile = void 0;
var tslib_1 = require("tslib");
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var file_1 = require("./file");
var utils_1 = require("./../../utils");
var filestack_error_1 = require("./../../../filestack_error");
var file_tools_1 = require("./file_tools");
/**
 * Check if file is buffer
 *
 * @node
 * @param input
 */
var isFileBuffer = function (input) { return Buffer.isBuffer(input); };
/**
 * Check if input is a valid file path
 *
 * @node
 * @param input
 */
var isFilePath = function (input) { return require('fs').existsSync(input); };
/**
 * Check if file is base64 string
 *
 * @param input
 */
var isFileBase = function (input) {
    if (typeof input !== 'string') {
        return false;
    }
    if (input.indexOf('base64') > -1 && file_tools_1.base64Regexp.test(input)) {
        input = input.match(file_tools_1.base64Regexp).pop();
    }
    if (Buffer.from(input, 'base64').toString('base64') === input) {
        return true;
    }
    return false;
};
/**
 * Accepts Buffer or filepath or base64 string
 *
 * @node
 * @param {*} inputFile
 * @returns {Promise<File>}
 */
var getFile = function (input, sanitizeOptions) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var filename, path_1, matches, mime_1;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if ((0, file_tools_1.isFileNamed)(input)) {
                    filename = input.name;
                    input = input.file;
                }
                if (isFilePath(input)) {
                    path_1 = input;
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            require('fs').readFile(path_1, function (err, buffer) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                                var mime;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (err) {
                                                return [2 /*return*/, reject(err)];
                                            }
                                            if (!filename) {
                                                filename = require && require('path').basename(path_1);
                                            }
                                            return [4 /*yield*/, (0, utils_1.getMimetype)(buffer, filename)];
                                        case 1:
                                            mime = _a.sent();
                                            return [2 /*return*/, resolve(new file_1.File({
                                                    name: filename,
                                                    size: buffer.byteLength,
                                                    type: mime,
                                                    slice: function (start, end) { return Promise.resolve(buffer.slice(start, end)); },
                                                }, sanitizeOptions))];
                                    }
                                });
                            }); });
                        })];
                }
                if (isFileBase(input)) {
                    matches = input.match(file_tools_1.base64Regexp);
                    if (matches && matches.length === 2) {
                        input = Buffer.from(matches[2], 'base64');
                    }
                    else {
                        input = Buffer.from(input, 'base64');
                    }
                }
                if (!isFileBuffer(input)) return [3 /*break*/, 2];
                return [4 /*yield*/, (0, utils_1.getMimetype)(input, filename)];
            case 1:
                mime_1 = _a.sent();
                return [2 /*return*/, Promise.resolve(new file_1.File({
                        name: filename,
                        size: input.byteLength,
                        type: mime_1,
                        // @ts-ignore
                        slice: function (start, end) { return Promise.resolve(input.slice(start, end)); },
                    }, sanitizeOptions))];
            case 2: return [2 /*return*/, Promise.reject(new filestack_error_1.FilestackError('Unsupported input file type'))];
        }
    });
}); };
exports.getFile = getFile;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLm5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILCtCQUF3QztBQUN4Qyx1Q0FBNkQ7QUFDN0QsOERBQTREO0FBQzVELDJDQUFvRTtBQUVwRTs7Ozs7R0FLRztBQUNILElBQU0sWUFBWSxHQUFHLFVBQUMsS0FBZ0IsSUFBc0IsT0FBQSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUF0QixDQUFzQixDQUFDO0FBRW5GOzs7OztHQUtHO0FBQ0gsSUFBTSxVQUFVLEdBQUcsVUFBQyxLQUFnQixJQUFzQixPQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQS9CLENBQStCLENBQUM7QUFFMUY7Ozs7R0FJRztBQUNILElBQU0sVUFBVSxHQUFHLFVBQUMsS0FBZ0I7SUFDbEMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSx5QkFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM1RCxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyx5QkFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDekM7SUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxLQUFLLEVBQUU7UUFDN0QsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ0ksSUFBTSxPQUFPLEdBQUcsVUFBTSxLQUFnQixFQUFFLGVBQWlDOzs7OztnQkFHOUUsSUFBSSxJQUFBLHdCQUFXLEVBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ3RCLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO29CQUN0QixLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztpQkFDcEI7Z0JBRUQsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ2pCLFNBQU8sS0FBSyxDQUFDO29CQUNqQixzQkFBTyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNOzRCQUNqQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQUksRUFBRSxVQUFNLEdBQUcsRUFBRSxNQUFNOzs7Ozs0Q0FDNUMsSUFBSSxHQUFHLEVBQUU7Z0RBQ1Asc0JBQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFDOzZDQUNwQjs0Q0FFRCxJQUFJLENBQUMsUUFBUSxFQUFFO2dEQUNiLFFBQVEsR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFJLENBQUMsQ0FBQzs2Q0FDdEQ7NENBQ1UscUJBQU0sSUFBQSxtQkFBVyxFQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsRUFBQTs7NENBQTFDLElBQUksR0FBRyxTQUFtQzs0Q0FDOUMsc0JBQU8sT0FBTyxDQUNaLElBQUksV0FBTSxDQUNSO29EQUNFLElBQUksRUFBRSxRQUFRO29EQUNkLElBQUksRUFBRSxNQUFNLENBQUMsVUFBVTtvREFDdkIsSUFBSSxFQUFFLElBQUk7b0RBQ1YsS0FBSyxFQUFFLFVBQUMsS0FBSyxFQUFFLEdBQUcsSUFBSyxPQUFBLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBekMsQ0FBeUM7aURBQ2pFLEVBQ0QsZUFBZSxDQUNoQixDQUNGLEVBQUM7OztpQ0FDSCxDQUFDLENBQUM7d0JBQ0wsQ0FBQyxDQUFDLEVBQUM7aUJBQ0o7Z0JBRUQsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ2YsT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMseUJBQVksQ0FBQyxDQUFDO29CQUMxQyxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTt3QkFDbkMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3FCQUMzQzt5QkFBTTt3QkFDTCxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7cUJBQ3RDO2lCQUNGO3FCQUVHLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBbkIsd0JBQW1CO2dCQUNWLHFCQUFNLElBQUEsbUJBQVcsRUFBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUE7O2dCQUF6QyxTQUFPLFNBQWtDO2dCQUM3QyxzQkFBTyxPQUFPLENBQUMsT0FBTyxDQUNwQixJQUFJLFdBQU0sQ0FDUjt3QkFDRSxJQUFJLEVBQUUsUUFBUTt3QkFDZCxJQUFJLEVBQUUsS0FBSyxDQUFDLFVBQVU7d0JBQ3RCLElBQUksRUFBRSxNQUFJO3dCQUNWLGFBQWE7d0JBQ2IsS0FBSyxFQUFFLFVBQUMsS0FBSyxFQUFFLEdBQUcsSUFBSyxPQUFBLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBeEMsQ0FBd0M7cUJBQ2hFLEVBQ0QsZUFBZSxDQUNoQixDQUNGLEVBQUM7b0JBR0osc0JBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLGdDQUFjLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxFQUFDOzs7S0FDMUUsQ0FBQztBQTdEVyxRQUFBLE9BQU8sV0E2RGxCIiwiZmlsZSI6ImxpYi9hcGkvdXBsb2FkL2ZpbGVfdG9vbHMubm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBGaWxlIGFzIEZzRmlsZSB9IGZyb20gJy4vZmlsZSc7XG5pbXBvcnQgeyBTYW5pdGl6ZU9wdGlvbnMsIGdldE1pbWV0eXBlIH0gZnJvbSAnLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgeyBGaWxlc3RhY2tFcnJvciB9IGZyb20gJy4vLi4vLi4vLi4vZmlsZXN0YWNrX2Vycm9yJztcbmltcG9ydCB7IElucHV0RmlsZSwgYmFzZTY0UmVnZXhwLCBpc0ZpbGVOYW1lZCB9IGZyb20gJy4vZmlsZV90b29scyc7XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBpcyBidWZmZXJcbiAqXG4gKiBAbm9kZVxuICogQHBhcmFtIGlucHV0XG4gKi9cbmNvbnN0IGlzRmlsZUJ1ZmZlciA9IChpbnB1dDogSW5wdXRGaWxlKTogaW5wdXQgaXMgQnVmZmVyID0+IEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgaW5wdXQgaXMgYSB2YWxpZCBmaWxlIHBhdGhcbiAqXG4gKiBAbm9kZVxuICogQHBhcmFtIGlucHV0XG4gKi9cbmNvbnN0IGlzRmlsZVBhdGggPSAoaW5wdXQ6IElucHV0RmlsZSk6IGlucHV0IGlzIHN0cmluZyA9PiByZXF1aXJlKCdmcycpLmV4aXN0c1N5bmMoaW5wdXQpO1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgaXMgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSBpbnB1dFxuICovXG5jb25zdCBpc0ZpbGVCYXNlID0gKGlucHV0OiBJbnB1dEZpbGUpOiBpbnB1dCBpcyBzdHJpbmcgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpbnB1dC5pbmRleE9mKCdiYXNlNjQnKSA+IC0xICYmIGJhc2U2NFJlZ2V4cC50ZXN0KGlucHV0KSkge1xuICAgIGlucHV0ID0gaW5wdXQubWF0Y2goYmFzZTY0UmVnZXhwKS5wb3AoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiYXNlNjQnKSA9PT0gaW5wdXQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQWNjZXB0cyBCdWZmZXIgb3IgZmlsZXBhdGggb3IgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBub2RlXG4gKiBAcGFyYW0geyp9IGlucHV0RmlsZVxuICogQHJldHVybnMge1Byb21pc2U8RmlsZT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGaWxlID0gYXN5bmMoaW5wdXQ6IElucHV0RmlsZSwgc2FuaXRpemVPcHRpb25zPzogU2FuaXRpemVPcHRpb25zKTogUHJvbWlzZTxGc0ZpbGU+ID0+IHtcbiAgbGV0IGZpbGVuYW1lO1xuXG4gIGlmIChpc0ZpbGVOYW1lZChpbnB1dCkpIHtcbiAgICBmaWxlbmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgaW5wdXQgPSBpbnB1dC5maWxlO1xuICB9XG5cbiAgaWYgKGlzRmlsZVBhdGgoaW5wdXQpKSB7XG4gICAgbGV0IHBhdGggPSBpbnB1dDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWlyZSgnZnMnKS5yZWFkRmlsZShwYXRoLCBhc3luYyhlcnIsIGJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgICAgIGZpbGVuYW1lID0gcmVxdWlyZSAmJiByZXF1aXJlKCdwYXRoJykuYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1pbWUgPSBhd2FpdCBnZXRNaW1ldHlwZShidWZmZXIsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoXG4gICAgICAgICAgbmV3IEZzRmlsZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHNpemU6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICB0eXBlOiBtaW1lLFxuICAgICAgICAgICAgICBzbGljZTogKHN0YXJ0LCBlbmQpID0+IFByb21pc2UucmVzb2x2ZShidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbml0aXplT3B0aW9uc1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzRmlsZUJhc2UoaW5wdXQpKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGlucHV0Lm1hdGNoKGJhc2U2NFJlZ2V4cCk7XG4gICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20obWF0Y2hlc1syXSwgJ2Jhc2U2NCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCAnYmFzZTY0Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRmlsZUJ1ZmZlcihpbnB1dCkpIHtcbiAgICBsZXQgbWltZSA9IGF3YWl0IGdldE1pbWV0eXBlKGlucHV0LCBmaWxlbmFtZSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgIG5ldyBGc0ZpbGUoXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICBzaXplOiBpbnB1dC5ieXRlTGVuZ3RoLFxuICAgICAgICAgIHR5cGU6IG1pbWUsXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHNsaWNlOiAoc3RhcnQsIGVuZCkgPT4gUHJvbWlzZS5yZXNvbHZlKGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgICAgfSxcbiAgICAgICAgc2FuaXRpemVPcHRpb25zXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmlsZXN0YWNrRXJyb3IoJ1Vuc3VwcG9ydGVkIGlucHV0IGZpbGUgdHlwZScpKTtcbn07XG4iXX0=
