"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.File = void 0;
var tslib_1 = require("tslib");
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var utils_1 = require("./../../utils");
/**
 * File representation to unify file object in nodejs and browser
 *
 * @export
 * @class File
 */
var File = /** @class */ (function () {
    function File(_file, _sanitizeOptions) {
        this._file = _file;
        this._sanitizeOptions = _sanitizeOptions;
        this._file.name = (0, utils_1.sanitizeName)(this._file.name, this._sanitizeOptions);
    }
    Object.defineProperty(File.prototype, "name", {
        /**
         * Returns file name
         *
         * @returns {string}
         * @memberof File
         */
        get: function () {
            return this._file.name;
        },
        /**
         * Sets new file name  and cleanup extra chars
         *
         * @memberof File
         */
        set: function (val) {
            this._file.name = (0, utils_1.sanitizeName)(val, this._sanitizeOptions);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "filename", {
        /**
         * Alias for name getter
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "customName", {
        /**
         * Sets custom name using string or function
         * Name will be sanitized
         *
         * @memberof File
         */
        set: function (val) {
            switch (typeof val) {
                case 'string':
                    this.name = val;
                    break;
                case 'function':
                    var newName = val(this);
                    if (typeof newName !== 'string') {
                        throw new Error("Name function must return a string. Current return type is ".concat(typeof val));
                    }
                    this.name = val(this);
                    break;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "type", {
        /**
         * Returns file type
         *
         * @default 'application/octet-stream'
         * @returns {string}
         * @memberof File
         */
        get: function () {
            /* istanbul ignore next */
            return this._file.type || 'application/octet-stream';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "mimetype", {
        /**
         * Alias for file type
         *
         * @readonly
         * @type {string}
         * @memberof File
         */
        get: function () {
            return this.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(File.prototype, "size", {
        /**
         * Returns file size
         *
         * @returns {number}
         * @memberof File
         */
        get: function () {
            return this._file.size;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns number of parts and part size according to max limit
     * @param {number} size - part size in bytes
     * @returns {PartSize}
     * @memberof File
     */
    File.prototype.getPartsCount = function (size, intelligentChunk) {
        var DEFAULT_FILE_SIZE_LIMIT = 59 * 1024 * 1024 * 1024;
        var INTELLIGENT_FILE_SIZE_LIMIT = 79 * 1024 * 1024 * 1024;
        var FILE_SIZE_LIMIT = intelligentChunk ? INTELLIGENT_FILE_SIZE_LIMIT : DEFAULT_FILE_SIZE_LIMIT;
        var MAX_S3_CHUNKS_ALLOWED = 10000;
        // When file size is greater than 60GB, chunk size is calculated dynamically
        // Chunk count is set to the max number of chunks allowed over s3
        if (this._file.size >= FILE_SIZE_LIMIT) {
            var dynamicPartSize = Math.ceil(this._file.size / MAX_S3_CHUNKS_ALLOWED); // size is set in bytes
            return {
                partsCount: Math.ceil(this._file.size / dynamicPartSize),
                chunkSize: dynamicPartSize,
            };
        }
        return {
            partsCount: Math.ceil(this._file.size / size),
            chunkSize: size,
        };
    };
    /**
     * Returns part metadata
     *
     * @param {number} [partNum=0]
     * @param {*} size
     * @returns {FilePartMetadata}
     * @memberof File
     */
    File.prototype.getPartMetadata = function (partNum, size) {
        var startByte = size * partNum;
        if (startByte > this._file.size) {
            throw new Error("Start byte of the part is higher than buffer size");
        }
        var endByte = Math.min(startByte + size, this._file.size);
        return {
            partNumber: partNum,
            startByte: startByte,
            endByte: endByte,
            size: endByte - startByte,
        };
    };
    /**
     * Returns part metadata + buffer
     *
     * @param {FilePartMetadata} meta
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getPartByMetadata = function (meta, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._file.slice(meta.startByte, meta.endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(tslib_1.__assign(tslib_1.__assign({}, meta), { buffer: slice, md5: md5Enabled ? (0, utils_1.md5)(slice) : undefined }))];
                }
            });
        });
    };
    /**
     * Returns part chunk
     *
     * @param {FilePartMetadata} meta
     * @param {number} offset
     * @param {number} chunkSize
     * @returns {FilePart}
     * @memberof File
     */
    File.prototype.getChunkByMetadata = function (meta, offset, chunkSize, md5Enabled) {
        if (md5Enabled === void 0) { md5Enabled = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var startByte, endByte, slice;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startByte = meta.startByte + offset;
                        endByte = Math.min(startByte + chunkSize, meta.endByte);
                        return [4 /*yield*/, this._file.slice(startByte, endByte)];
                    case 1:
                        slice = _a.sent();
                        return [2 /*return*/, Promise.resolve(tslib_1.__assign(tslib_1.__assign({}, meta), { buffer: slice, md5: md5Enabled ? (0, utils_1.md5)(slice) : undefined, size: slice.byteLength, startByte: startByte, endByte: endByte, offset: offset }))];
                }
            });
        });
    };
    /**
     * Cleanup file buffer to release memory
     *
     * @memberof File
     */
    File.prototype.release = function () {
        if (this._file.release) {
            this._file.release();
        }
    };
    File.prototype.toJSON = function () {
        return {
            name: this.name,
            status: this.status,
            type: this.type,
            size: this.size,
            url: this.url,
            handle: this.handle,
            uploadTags: this.uploadTags,
        };
    };
    return File;
}());
exports.File = File;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCx1Q0FBbUU7QUEyQ25FOzs7OztHQUtHO0FBQ0g7SUFrQkUsY0FBNkIsS0FBbUIsRUFBbUIsZ0JBQWtDO1FBQXhFLFVBQUssR0FBTCxLQUFLLENBQWM7UUFBbUIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNuRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFBLG9CQUFZLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDekUsQ0FBQztJQVFELHNCQUFXLHNCQUFJO1FBTmY7Ozs7O1dBS0c7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFDekIsQ0FBQztRQWFEOzs7O1dBSUc7YUFDSCxVQUFnQixHQUFXO1lBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLElBQUEsb0JBQVksRUFBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDN0QsQ0FBQzs7O09BcEJBO0lBU0Qsc0JBQVcsMEJBQVE7UUFQbkI7Ozs7OztXQU1HO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsQ0FBQzs7O09BQUE7SUFpQkQsc0JBQVcsNEJBQVU7UUFOckI7Ozs7O1dBS0c7YUFDSCxVQUFzQixHQUFzQztZQUMxRCxRQUFRLE9BQU8sR0FBRyxFQUFFO2dCQUNsQixLQUFLLFFBQVE7b0JBQ1gsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7b0JBQ2hCLE1BQU07Z0JBQ1IsS0FBSyxVQUFVO29CQUNiLElBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDMUIsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVB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QyxNQUFNO1lBQ25CLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztZQUNiLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7U0FDNUIsQ0FBQztJQUNKLENBQUM7SUFDSCxXQUFDO0FBQUQsQ0FsT0EsQUFrT0MsSUFBQTtBQWxPWSxvQkFBSSIsImZpbGUiOiJsaWIvYXBpL3VwbG9hZC9maWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBieSBGaWxlc3RhY2suXG4gKiBTb21lIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IG1kNSwgc2FuaXRpemVOYW1lLCBTYW5pdGl6ZU9wdGlvbnMgfSBmcm9tICcuLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRUYWdzIHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVJbnN0YW5jZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICBzaXplOiBudW1iZXI7XG4gIHNsaWNlOiAoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IFByb21pc2U8QXJyYXlCdWZmZXI+O1xuICByZWxlYXNlPzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gRmlsZVN0YXRlIHtcbiAgSU5JVCA9ICdJbml0aWFsaXplZCcsXG4gIFBST0dSRVNTID0gJ1Byb2dyZXNzJyxcbiAgU1RPUkVEID0gJ1N0b3JlZCcsXG4gIElOVFJBTlNJVCA9ICdJblRyYW5zaXQnLFxuICBGQUlMRUQgPSAnRmFpbGVkJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlUGFydE1ldGFkYXRhIHtcbiAgc3RhcnRCeXRlOiBudW1iZXI7XG4gIGVuZEJ5dGU6IG51bWJlcjtcbiAgcGFydE51bWJlcjogbnVtYmVyO1xuICBzaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVBhcnQgZXh0ZW5kcyBGaWxlUGFydE1ldGFkYXRhIHtcbiAgYnVmZmVyOiBCdWZmZXIgfCBBcnJheUJ1ZmZlcjtcbiAgbWQ1Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDaHVuayBleHRlbmRzIEZpbGVQYXJ0IHtcbiAgb2Zmc2V0OiBudW1iZXI7IC8vIG9mZnNldCBmb3IgY2h1bmsgLSBmcm9tIHBhcnQgc3RhcnRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0U2l6ZSB7XG4gIHBhcnRzQ291bnQ6IG51bWJlcjtcbiAgY2h1bmtTaXplOiBudW1iZXI7XG59XG5cbi8qKlxuICogRmlsZSByZXByZXNlbnRhdGlvbiB0byB1bmlmeSBmaWxlIG9iamVjdCBpbiBub2RlanMgYW5kIGJyb3dzZXJcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRmlsZVxuICovXG5leHBvcnQgY2xhc3MgRmlsZSB7XG5cbiAgcHVibGljIHN0YXR1czogRmlsZVN0YXRlO1xuXG4gIHB1YmxpYyBoYW5kbGU6IHN0cmluZztcblxuICBwdWJsaWMgdXJsOiBzdHJpbmc7XG5cbiAgcHVibGljIGNvbnRhaW5lcjogc3RyaW5nO1xuXG4gIHB1YmxpYyBrZXk6IHN0cmluZztcblxuICBwdWJsaWMgd29ya2Zsb3dzOiBhbnlbXTtcblxuICBwdWJsaWMgdXBsb2FkVGFnczogVXBsb2FkVGFncztcblxuICBwdWJsaWMgYWx0OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfZmlsZTogRmlsZUluc3RhbmNlLCBwcml2YXRlIHJlYWRvbmx5IF9zYW5pdGl6ZU9wdGlvbnM/OiBTYW5pdGl6ZU9wdGlvbnMpIHtcbiAgICB0aGlzLl9maWxlLm5hbWUgPSBzYW5pdGl6ZU5hbWUodGhpcy5fZmlsZS5uYW1lLCB0aGlzLl9zYW5pdGl6ZU9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsZSBuYW1lXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBuYW1lIGdldHRlclxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXQgZmlsZW5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbmV3IGZpbGUgbmFtZSAgYW5kIGNsZWFudXAgZXh0cmEgY2hhcnNcbiAgICpcbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBzZXQgbmFtZSh2YWw6IHN0cmluZykge1xuICAgIHRoaXMuX2ZpbGUubmFtZSA9IHNhbml0aXplTmFtZSh2YWwsIHRoaXMuX3Nhbml0aXplT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBjdXN0b20gbmFtZSB1c2luZyBzdHJpbmcgb3IgZnVuY3Rpb25cbiAgICogTmFtZSB3aWxsIGJlIHNhbml0aXplZFxuICAgKlxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIHNldCBjdXN0b21OYW1lKHZhbDogKChmaWxlOiB0aGlzKSA9PiBzdHJpbmcpIHwgc3RyaW5nKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLm5hbWUgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBjb25zdCBuZXdOYW1lID0gdmFsKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIG5ld05hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgc3RyaW5nLiBDdXJyZW50IHJldHVybiB0eXBlIGlzICR7dHlwZW9mIHZhbH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmFtZSA9IHZhbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsZSB0eXBlXG4gICAqXG4gICAqIEBkZWZhdWx0ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLl9maWxlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIGZpbGUgdHlwZVxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQG1lbWJlcm9mIEZpbGVcbiAgICovXG4gIHB1YmxpYyBnZXQgbWltZXR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsZSBzaXplXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIHBhcnRzIGFuZCBwYXJ0IHNpemUgYWNjb3JkaW5nIHRvIG1heCBsaW1pdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIHBhcnQgc2l6ZSBpbiBieXRlc1xuICAgKiBAcmV0dXJucyB7UGFydFNpemV9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFydHNDb3VudCAoc2l6ZTogbnVtYmVyLCBpbnRlbGxpZ2VudENodW5rOiBib29sZWFuKTogUGFydFNpemUge1xuICAgIGNvbnN0IERFRkFVTFRfRklMRV9TSVpFX0xJTUlUID0gNTkgKiAxMDI0ICogMTAyNCAqIDEwMjQ7XG4gICAgY29uc3QgSU5URUxMSUdFTlRfRklMRV9TSVpFX0xJTUlUID0gNzkgKiAxMDI0ICogMTAyNCAqIDEwMjQ7XG4gICAgY29uc3QgRklMRV9TSVpFX0xJTUlUID0gaW50ZWxsaWdlbnRDaHVuayA/IElOVEVMTElHRU5UX0ZJTEVfU0laRV9MSU1JVCA6IERFRkFVTFRfRklMRV9TSVpFX0xJTUlUO1xuICAgIGNvbnN0IE1BWF9TM19DSFVOS1NfQUxMT1dFRCA9IDEwMDAwO1xuXG4gICAgLy8gV2hlbiBmaWxlIHNpemUgaXMgZ3JlYXRlciB0aGFuIDYwR0IsIGNodW5rIHNpemUgaXMgY2FsY3VsYXRlZCBkeW5hbWljYWxseVxuICAgIC8vIENodW5rIGNvdW50IGlzIHNldCB0byB0aGUgbWF4IG51bWJlciBvZiBjaHVua3MgYWxsb3dlZCBvdmVyIHMzXG4gICAgaWYgKHRoaXMuX2ZpbGUuc2l6ZSA+PSBGSUxFX1NJWkVfTElNSVQpIHtcbiAgICAgIGNvbnN0IGR5bmFtaWNQYXJ0U2l6ZSA9IE1hdGguY2VpbCh0aGlzLl9maWxlLnNpemUgLyBNQVhfUzNfQ0hVTktTX0FMTE9XRUQpOyAvLyBzaXplIGlzIHNldCBpbiBieXRlc1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJ0c0NvdW50OiBNYXRoLmNlaWwodGhpcy5fZmlsZS5zaXplIC8gZHluYW1pY1BhcnRTaXplKSxcbiAgICAgICAgY2h1bmtTaXplOiBkeW5hbWljUGFydFNpemUsXG4gICAgICB9O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcnRzQ291bnQ6IE1hdGguY2VpbCh0aGlzLl9maWxlLnNpemUgLyBzaXplKSxcbiAgICAgIGNodW5rU2l6ZTogc2l6ZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcGFydCBtZXRhZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcnROdW09MF1cbiAgICogQHBhcmFtIHsqfSBzaXplXG4gICAqIEByZXR1cm5zIHtGaWxlUGFydE1ldGFkYXRhfVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGdldFBhcnRNZXRhZGF0YSAocGFydE51bTogbnVtYmVyLCBzaXplOiBudW1iZXIpOiBGaWxlUGFydE1ldGFkYXRhIHtcbiAgICBjb25zdCBzdGFydEJ5dGUgPSBzaXplICogcGFydE51bTtcblxuICAgIGlmIChzdGFydEJ5dGUgPiB0aGlzLl9maWxlLnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhcnQgYnl0ZSBvZiB0aGUgcGFydCBpcyBoaWdoZXIgdGhhbiBidWZmZXIgc2l6ZWApO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZEJ5dGUgPSBNYXRoLm1pbihzdGFydEJ5dGUgKyBzaXplLCB0aGlzLl9maWxlLnNpemUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcnROdW1iZXI6IHBhcnROdW0sXG4gICAgICBzdGFydEJ5dGUsXG4gICAgICBlbmRCeXRlLFxuICAgICAgc2l6ZTogZW5kQnl0ZSAtIHN0YXJ0Qnl0ZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcGFydCBtZXRhZGF0YSArIGJ1ZmZlclxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVQYXJ0TWV0YWRhdGF9IG1ldGFcbiAgICogQHJldHVybnMge0ZpbGVQYXJ0fVxuICAgKiBAbWVtYmVyb2YgRmlsZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldFBhcnRCeU1ldGFkYXRhKG1ldGE6IEZpbGVQYXJ0TWV0YWRhdGEsIG1kNUVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxGaWxlUGFydD4ge1xuICAgIGxldCBzbGljZSA9IGF3YWl0IHRoaXMuX2ZpbGUuc2xpY2UobWV0YS5zdGFydEJ5dGUsIG1ldGEuZW5kQnl0ZSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIC4uLm1ldGEsXG4gICAgICBidWZmZXI6IHNsaWNlLFxuICAgICAgbWQ1OiBtZDVFbmFibGVkID8gbWQ1KHNsaWNlKSA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcnQgY2h1bmtcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlUGFydE1ldGFkYXRhfSBtZXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNodW5rU2l6ZVxuICAgKiBAcmV0dXJucyB7RmlsZVBhcnR9XG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0Q2h1bmtCeU1ldGFkYXRhKG1ldGE6IEZpbGVQYXJ0TWV0YWRhdGEsIG9mZnNldDogbnVtYmVyLCBjaHVua1NpemU6IG51bWJlciwgbWQ1RW5hYmxlZDogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPEZpbGVDaHVuaz4ge1xuICAgIGNvbnN0IHN0YXJ0Qnl0ZSA9IG1ldGEuc3RhcnRCeXRlICsgb2Zmc2V0O1xuICAgIGNvbnN0IGVuZEJ5dGUgPSBNYXRoLm1pbihzdGFydEJ5dGUgKyBjaHVua1NpemUsIG1ldGEuZW5kQnl0ZSk7XG5cbiAgICBsZXQgc2xpY2UgPSBhd2FpdCB0aGlzLl9maWxlLnNsaWNlKHN0YXJ0Qnl0ZSwgZW5kQnl0ZSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIC4uLm1ldGEsXG4gICAgICBidWZmZXI6IHNsaWNlLFxuICAgICAgbWQ1OiBtZDVFbmFibGVkID8gbWQ1KHNsaWNlKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNpemU6IHNsaWNlLmJ5dGVMZW5ndGgsXG4gICAgICBzdGFydEJ5dGUsXG4gICAgICBlbmRCeXRlLFxuICAgICAgb2Zmc2V0LFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbnVwIGZpbGUgYnVmZmVyIHRvIHJlbGVhc2UgbWVtb3J5XG4gICAqXG4gICAqIEBtZW1iZXJvZiBGaWxlXG4gICAqL1xuICBwdWJsaWMgcmVsZWFzZSgpIHtcbiAgICBpZiAodGhpcy5fZmlsZS5yZWxlYXNlKSB7XG4gICAgICB0aGlzLl9maWxlLnJlbGVhc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGUsXG4gICAgICB1cGxvYWRUYWdzOiB0aGlzLnVwbG9hZFRhZ3MsXG4gICAgfTtcbiAgfVxufVxuIl19
