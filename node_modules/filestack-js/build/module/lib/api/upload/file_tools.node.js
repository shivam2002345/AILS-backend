import { __awaiter, __generator } from "tslib";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { File as FsFile } from './file';
import { getMimetype } from './../../utils';
import { FilestackError } from './../../../filestack_error';
import { base64Regexp, isFileNamed } from './file_tools';
/**
 * Check if file is buffer
 *
 * @node
 * @param input
 */
var isFileBuffer = function (input) { return Buffer.isBuffer(input); };
/**
 * Check if input is a valid file path
 *
 * @node
 * @param input
 */
var isFilePath = function (input) { return require('fs').existsSync(input); };
/**
 * Check if file is base64 string
 *
 * @param input
 */
var isFileBase = function (input) {
    if (typeof input !== 'string') {
        return false;
    }
    if (input.indexOf('base64') > -1 && base64Regexp.test(input)) {
        input = input.match(base64Regexp).pop();
    }
    if (Buffer.from(input, 'base64').toString('base64') === input) {
        return true;
    }
    return false;
};
/**
 * Accepts Buffer or filepath or base64 string
 *
 * @node
 * @param {*} inputFile
 * @returns {Promise<File>}
 */
export var getFile = function (input, sanitizeOptions) { return __awaiter(void 0, void 0, void 0, function () {
    var filename, path_1, matches, mime_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (isFileNamed(input)) {
                    filename = input.name;
                    input = input.file;
                }
                if (isFilePath(input)) {
                    path_1 = input;
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            require('fs').readFile(path_1, function (err, buffer) { return __awaiter(void 0, void 0, void 0, function () {
                                var mime;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (err) {
                                                return [2 /*return*/, reject(err)];
                                            }
                                            if (!filename) {
                                                filename = require && require('path').basename(path_1);
                                            }
                                            return [4 /*yield*/, getMimetype(buffer, filename)];
                                        case 1:
                                            mime = _a.sent();
                                            return [2 /*return*/, resolve(new FsFile({
                                                    name: filename,
                                                    size: buffer.byteLength,
                                                    type: mime,
                                                    slice: function (start, end) { return Promise.resolve(buffer.slice(start, end)); },
                                                }, sanitizeOptions))];
                                    }
                                });
                            }); });
                        })];
                }
                if (isFileBase(input)) {
                    matches = input.match(base64Regexp);
                    if (matches && matches.length === 2) {
                        input = Buffer.from(matches[2], 'base64');
                    }
                    else {
                        input = Buffer.from(input, 'base64');
                    }
                }
                if (!isFileBuffer(input)) return [3 /*break*/, 2];
                return [4 /*yield*/, getMimetype(input, filename)];
            case 1:
                mime_1 = _a.sent();
                return [2 /*return*/, Promise.resolve(new FsFile({
                        name: filename,
                        size: input.byteLength,
                        type: mime_1,
                        // @ts-ignore
                        slice: function (start, end) { return Promise.resolve(input.slice(start, end)); },
                    }, sanitizeOptions))];
            case 2: return [2 /*return*/, Promise.reject(new FilestackError('Unsupported input file type'))];
        }
    });
}); };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLm5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBRSxJQUFJLElBQUksTUFBTSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3hDLE9BQU8sRUFBbUIsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM1RCxPQUFPLEVBQWEsWUFBWSxFQUFFLFdBQVcsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUVwRTs7Ozs7R0FLRztBQUNILElBQU0sWUFBWSxHQUFHLFVBQUMsS0FBZ0IsSUFBc0IsT0FBQSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUF0QixDQUFzQixDQUFDO0FBRW5GOzs7OztHQUtHO0FBQ0gsSUFBTSxVQUFVLEdBQUcsVUFBQyxLQUFnQixJQUFzQixPQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQS9CLENBQStCLENBQUM7QUFFMUY7Ozs7R0FJRztBQUNILElBQU0sVUFBVSxHQUFHLFVBQUMsS0FBZ0I7SUFDbEMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzVELEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3pDO0lBRUQsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQzdELE9B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ZGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRmlsZSBhcyBGc0ZpbGUgfSBmcm9tICcuL2ZpbGUnO1xuaW1wb3J0IHsgU2FuaXRpemVPcHRpb25zLCBnZXRNaW1ldHlwZSB9IGZyb20gJy4vLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgRmlsZXN0YWNrRXJyb3IgfSBmcm9tICcuLy4uLy4uLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBJbnB1dEZpbGUsIGJhc2U2NFJlZ2V4cCwgaXNGaWxlTmFtZWQgfSBmcm9tICcuL2ZpbGVfdG9vbHMnO1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgaXMgYnVmZmVyXG4gKlxuICogQG5vZGVcbiAqIEBwYXJhbSBpbnB1dFxuICovXG5jb25zdCBpc0ZpbGVCdWZmZXIgPSAoaW5wdXQ6IElucHV0RmlsZSk6IGlucHV0IGlzIEJ1ZmZlciA9PiBCdWZmZXIuaXNCdWZmZXIoaW5wdXQpO1xuXG4vKipcbiAqIENoZWNrIGlmIGlucHV0IGlzIGEgdmFsaWQgZmlsZSBwYXRoXG4gKlxuICogQG5vZGVcbiAqIEBwYXJhbSBpbnB1dFxuICovXG5jb25zdCBpc0ZpbGVQYXRoID0gKGlucHV0OiBJbnB1dEZpbGUpOiBpbnB1dCBpcyBzdHJpbmcgPT4gcmVxdWlyZSgnZnMnKS5leGlzdHNTeW5jKGlucHV0KTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIGlzIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gaW5wdXRcbiAqL1xuY29uc3QgaXNGaWxlQmFzZSA9IChpbnB1dDogSW5wdXRGaWxlKTogaW5wdXQgaXMgc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaW5wdXQuaW5kZXhPZignYmFzZTY0JykgPiAtMSAmJiBiYXNlNjRSZWdleHAudGVzdChpbnB1dCkpIHtcbiAgICBpbnB1dCA9IGlucHV0Lm1hdGNoKGJhc2U2NFJlZ2V4cCkucG9wKCk7XG4gIH1cblxuICBpZiAoQnVmZmVyLmZyb20oaW5wdXQsICdiYXNlNjQnKS50b1N0cmluZygnYmFzZTY0JykgPT09IGlucHV0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgQnVmZmVyIG9yIGZpbGVwYXRoIG9yIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAbm9kZVxuICogQHBhcmFtIHsqfSBpbnB1dEZpbGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPEZpbGU+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0RmlsZSA9IGFzeW5jKGlucHV0OiBJbnB1dEZpbGUsIHNhbml0aXplT3B0aW9ucz86IFNhbml0aXplT3B0aW9ucyk6IFByb21pc2U8RnNGaWxlPiA9PiB7XG4gIGxldCBmaWxlbmFtZTtcblxuICBpZiAoaXNGaWxlTmFtZWQoaW5wdXQpKSB7XG4gICAgZmlsZW5hbWUgPSBpbnB1dC5uYW1lO1xuICAgIGlucHV0ID0gaW5wdXQuZmlsZTtcbiAgfVxuXG4gIGlmIChpc0ZpbGVQYXRoKGlucHV0KSkge1xuICAgIGxldCBwYXRoID0gaW5wdXQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGUocGF0aCwgYXN5bmMoZXJyLCBidWZmZXIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICBmaWxlbmFtZSA9IHJlcXVpcmUgJiYgcmVxdWlyZSgncGF0aCcpLmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtaW1lID0gYXdhaXQgZ2V0TWltZXR5cGUoYnVmZmVyLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKFxuICAgICAgICAgIG5ldyBGc0ZpbGUoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICBzaXplOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgdHlwZTogbWltZSxcbiAgICAgICAgICAgICAgc2xpY2U6IChzdGFydCwgZW5kKSA9PiBQcm9taXNlLnJlc29sdmUoYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW5pdGl6ZU9wdGlvbnNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0ZpbGVCYXNlKGlucHV0KSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBpbnB1dC5tYXRjaChiYXNlNjRSZWdleHApO1xuICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKG1hdGNoZXNbMl0sICdiYXNlNjQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0ZpbGVCdWZmZXIoaW5wdXQpKSB7XG4gICAgbGV0IG1pbWUgPSBhd2FpdCBnZXRNaW1ldHlwZShpbnB1dCwgZmlsZW5hbWUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICBuZXcgRnNGaWxlKFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgc2l6ZTogaW5wdXQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICB0eXBlOiBtaW1lLFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBzbGljZTogKHN0YXJ0LCBlbmQpID0+IFByb21pc2UucmVzb2x2ZShpbnB1dC5zbGljZShzdGFydCwgZW5kKSksXG4gICAgICAgIH0sXG4gICAgICAgIHNhbml0aXplT3B0aW9uc1xuICAgICAgKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZpbGVzdGFja0Vycm9yKCdVbnN1cHBvcnRlZCBpbnB1dCBmaWxlIHR5cGUnKSk7XG59O1xuIl19
